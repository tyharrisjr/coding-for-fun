"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AppInfosCache = void 0;
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const support_1 = require("appium/support");
const lru_cache_1 = require("lru-cache");
const bluebird_1 = __importDefault(require("bluebird"));
/** @type {LRUCache<string, import('@appium/types').StringRecord>} */
const MANIFEST_CACHE = new lru_cache_1.LRUCache({
    max: 40,
    updateAgeOnHas: true,
});
const MANIFEST_FILE_NAME = 'Info.plist';
const MAX_MANIFEST_SIZE = 1024 * 1024; // 1 MiB
class AppInfosCache {
    /**
     * @param {import('@appium/types').AppiumLogger} log
     */
    constructor(log) {
        this.log = log;
    }
    /**
     *
     * @param {string} appPath
     * @param {string} propertyName
     * @returns {Promise<any>}
     */
    async extractManifestProperty(appPath, propertyName) {
        const result = (await this.put(appPath))[propertyName];
        this.log.debug(`${propertyName}: ${JSON.stringify(result)}`);
        return result;
    }
    /**
     *
     * @param {string} appPath
     * @returns {Promise<string>}
     */
    async extractBundleId(appPath) {
        return await this.extractManifestProperty(appPath, 'CFBundleIdentifier');
    }
    /**
     *
     * @param {string} appPath
     * @returns {Promise<string>}
     */
    async extractBundleVersion(appPath) {
        return await this.extractManifestProperty(appPath, 'CFBundleVersion');
    }
    /**
     *
     * @param {string} appPath
     * @returns {Promise<string[]>}
     */
    async extractAppPlatforms(appPath) {
        const result = await this.extractManifestProperty(appPath, 'CFBundleSupportedPlatforms');
        if (!Array.isArray(result)) {
            throw new Error(`${path_1.default.basename(appPath)}': CFBundleSupportedPlatforms is not a valid list`);
        }
        return result;
    }
    /**
     *
     * @param {string} appPath
     * @returns {Promise<string>}
     */
    async extractExecutableName(appPath) {
        return await this.extractManifestProperty(appPath, 'CFBundleExecutable');
    }
    /**
     *
     * @param {string} appPath Full path to the .ipa or .app bundle
     * @returns {Promise<import('@appium/types').StringRecord>} The payload of the manifest plist
     * @throws {Error} If the given app is not a valid bundle
     */
    async put(appPath) {
        const readPlist = async (/** @type {string} */ plistPath) => {
            try {
                return await support_1.plist.parsePlistFile(plistPath);
            }
            catch (e) {
                this.log.debug(e.stack);
                throw new Error(`Cannot parse ${MANIFEST_FILE_NAME} of '${appPath}'. Is it a valid application bundle?`);
            }
        };
        if ((await support_1.fs.stat(appPath)).isFile()) {
            /** @type {import('@appium/types').StringRecord|undefined} */
            let manifestPayload;
            /** @type {Error|undefined} */
            let lastError;
            try {
                await support_1.zip.readEntries(appPath, async ({ entry, extractEntryTo }) => {
                    if (!lodash_1.default.endsWith(entry.fileName, `.app/${MANIFEST_FILE_NAME}`)) {
                        return true;
                    }
                    const hash = `${entry.crc32}`;
                    if (MANIFEST_CACHE.has(hash)) {
                        manifestPayload = MANIFEST_CACHE.get(hash);
                        return false;
                    }
                    const tmpRoot = await support_1.tempDir.openDir();
                    try {
                        await extractEntryTo(tmpRoot);
                        const plistPath = path_1.default.resolve(tmpRoot, entry.fileName);
                        manifestPayload = await readPlist(plistPath);
                        if (entry.uncompressedSize <= MAX_MANIFEST_SIZE && lodash_1.default.isPlainObject(manifestPayload)) {
                            this.log.debug(`Caching the manifest for ${manifestPayload?.CFBundleIdentifier} app ` +
                                `from an archived source using the key '${hash}'`);
                            MANIFEST_CACHE.set(hash, manifestPayload);
                        }
                    }
                    catch (e) {
                        this.log.debug(e.stack);
                        lastError = e;
                    }
                    finally {
                        await support_1.fs.rimraf(tmpRoot);
                    }
                    return false;
                });
            }
            catch (e) {
                this.log.debug(e.stack);
                throw new Error(`Cannot find ${MANIFEST_FILE_NAME} in '${appPath}'. Is it a valid application bundle?`);
            }
            if (!manifestPayload) {
                let errorMessage = `Cannot extract ${MANIFEST_FILE_NAME} from '${appPath}'. Is it a valid application bundle?`;
                if (lastError) {
                    errorMessage += ` Original error: ${lastError.message}`;
                }
                throw new Error(errorMessage);
            }
            return manifestPayload;
        }
        // appPath points to a folder
        const manifestPath = path_1.default.join(appPath, MANIFEST_FILE_NAME);
        const hash = await support_1.fs.hash(manifestPath);
        if (MANIFEST_CACHE.has(hash)) {
            return /** @type {import('@appium/types').StringRecord} */ (MANIFEST_CACHE.get(hash));
        }
        const [payload, stat] = await bluebird_1.default.all([
            readPlist(manifestPath),
            support_1.fs.stat(manifestPath),
        ]);
        if (stat.size <= MAX_MANIFEST_SIZE && lodash_1.default.isPlainObject(payload)) {
            this.log.debug(`Caching the manifest for ${payload.CFBundleIdentifier} app from a file source using the key '${hash}'`);
            MANIFEST_CACHE.set(hash, payload);
        }
        return payload;
    }
}
exports.AppInfosCache = AppInfosCache;
//# sourceMappingURL=app-infos-cache.js.map